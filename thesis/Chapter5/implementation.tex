\chapter{Implementation}

\section{Directory Structure}
The directory structure (for the application only) is defined as follows:

\begin{itemize}
    \item \textbf{app} contains various Laravel application components, such as models, controllers, and policies
    \item \textbf{bootstrap} Framework code used by Laravel to bootstrap the application
    \item \textbf{config} Framework code that define configurations for various Laravel utilities and functionalities
    \item \textbf{database} Database factories, migration definitions, and seeding tools are in this directory.
    \item \textbf{docs} Documentation generated by Sami is stored here. This is explored in more detail in Chapter 7.
    \item \textbf{node\_modules} This contains Node.js dependencies installed by Laravel Mix and are used in development. This is discussed in greater detail in Chapter 7.
    \item \textbf{public} is the front-facing directory containing the application entry-point, as well as compiled assets and images used for social media.
    \item \textbf{routes} HTTP Application routes are defined in the files contain within this directory.
    \item \textbf{resources} Views written in Laravel Blade are kept in this folder, along with stylesheets and scripts that comprise the front-end.
    \item \textbf{storage} Laravel stores log files here, and generated PDF files for download are kept here. A cache for quick loading is also stored here.
    \item \textbf{tests} PHPUnit tests are kept here, and are covered in Chapter 6.
    \item \textbf{vendor} Similar to \textit{node\_modules}, this folder stores PHP dependencies used by Laravel, as well as additional third-party libraries.
\end{itemize} \cite{W3Schools1}

\section{Method of Action}
The Laravel developers acknowledge that having a basic, high-level understanding of how a framework works is important for not only having a basic grasp of how the application works, but also to make 'everything feel less magical'. \cite{Laravel6} This is important as frameworks are characterised by carrying out substantial amounts of work for you, in order to drastically reduce development time and to produce better quality applications, and are generally recommended by the greater web development community. \cite{Mozilla3}

\begin{figure}[!ht]
    \includegraphics[width=1.0\textwidth]{Figures/laravel-request}
    \caption{Diagram that shows how the Request Lifecycle for the Laravel framework operates.}
    \label{fig:laravel-requests} \cite{Mallow1}
\end{figure}

When a HTTP (Hypertext Transfer Protocol) request is received by the web server by navigating to the \textbf{index.php} file in the \textit{public} directory, the application is quickly bootstrapped, loading all necessary libraries and components by means of the PSR-4 autoload file, which is a widely accepted PHP coding standard and was generated by Composer, the PHP package manager when the application was first installed. \cite{PSR1} From here, the application can determine how to 'route' the request based on route definitions and the URL (Uniform Resource Locator) path, delegating actions to the appropriate controllers and their models defined in those definitions, before passing data to a view, and returning it to the user. \cite{Laravel6} According to Stauffer, Laravel's approach 'brings your ideas to reality with no wasted code' and 'modern programming standards.' \cite{LaravelUp1}

\section{HTTP Routes}

\begin{figure}[!ht]
    \includegraphics[width=1.0\textwidth]{Figures/routes}
    \caption{A print out of HTTP routes defined within the application, their corresponding URLs, associated controllers and methods, and HTTP actions.}
    \label{fig:methods}
\end{figure}

The controllers for each resource (i.e. users, operations) as well as individual webpages uses a RESTful (Representational State Transfer) architecture, and have methods that correspond to the CRUD verbs - create, read, update, and delete. There are also additional methods that help facilitate the CRUD operations, such as 'show' for viewing individual entries, and 'edit' to display a form in order to modify an existing record. Different actions may expect different HTTP requests, such as GET, POST, PATCH, and DELETE respectively. Each action, whether viewing one's own profile, editing a user's profile, registering for a shift, or deleting an operation, are all represented by their own route within the application, including custom defined routes that do not correspond to CRUD, such as those used for (de)registering to an operation. \cite{Laravel7} \cite{7539825}

\section{Models and Relationships}

\begin{figure}[!ht]
    \includegraphics[width=1.0\textwidth]{Figures/Models}
    \caption{UML diagram showing the relationships between database tables and their structure. The relationships are defined by their Eloquent relationships.}
    \label{fig:relationships}
\end{figure}

Database models define their column names and data types within migration files, alongside foreign keys, their references, and any constraints. As shown by Figure \ref{fig:relationships}, many of the tables belong to shifts, as each shift can have corresponding vehicles associated with it, a designated location, a required role and competency level, as well as the volunteer that is assigned to that volunteer, which is of course null when the shift is vacant.

\section{Users}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=1.0\textwidth]{Figures/screenshot-users}
    \caption{Screenshot of the Users interface within the application.}
    \label{fig:users}
\end{figure}

All volunteers are users within the application, with users that have access to administrative privileges being denoted by a boolean true value in \textbf{is\_admin}. Users can modify a subset of their own information, but are unable to assign themselves roles or privileges, or modify a date value indicating the last time they were inspected.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=1.0\textwidth]{Figures/screenshot-edit-user}
    \caption{Screenshot of the Edit User interface, as seen by an administrator.}
    \label{fig:users-edit}
\end{figure}

The following destroy CRUD method in the User controller, demonstrates how after checking the policies that the current user is authorised to delete a user (so is an administrator), it checks first whether they are attempting to delete themselves, which is understandably undesirable behaviour, and redirects back with an error message if this is the case. Otherwise, the \textbf{delete} Eloquent method is called on the user object, and it is deleted from the database; redirecting back with a success notification. The User object is resolved from the unique ID in the URL. \cite{Laravel7}

\begin{lstlisting}[language=PHP, breaklines]
    public function destroy(User $user)
    {
        $this->authorize('delete', $user);

        if ($user->id === Auth::id()) {
            flash()->error('You can\'t delete yourself!')->important();
            return redirect()->back();
        }

        $user->delete();
        flash()->success("{$user->name} has been deleted successfully!")->important();
        return redirect()->route('users.index');
    }
\end{lstlisting}

\subsection{Authentication}
Authentication.

\subsection{Authorisation and Policies}

\section{Role Types}

\section{Role Competencies}

\section{Roles}

\section{Locations and Locomotives}

\section{Operations and Shifts}

\section{Calendar View}

\section{PDF Export Functionality}

\section{Administration Panel}

\section{Additional Webpages}