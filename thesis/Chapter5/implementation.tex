\chapter{Implementation}

\section{Directory Structure}
The directory structure (for the application only) is defined as follows:

\begin{itemize}
    \item \textbf{app} contains various Laravel application components, such as models, controllers, and policies
    \item \textbf{bootstrap} Framework code used by Laravel to bootstrap the application
    \item \textbf{config} Framework code that define configurations for various Laravel utilities and functionalities
    \item \textbf{database} Database factories, migration definitions, and seeding tools are in this directory.
    \item \textbf{docs} Documentation generated by Sami is stored here. This is explored in more detail in Chapter 7.
    \item \textbf{node\_modules} This contains Node.js dependencies installed by Laravel Mix and are used in development. This is discussed in greater detail in Chapter 7.
    \item \textbf{public} is the front-facing directory containing the application entry-point, as well as compiled assets and images used for social media.
    \item \textbf{routes} HTTP Application routes are defined in the files contain within this directory.
    \item \textbf{resources} Views written in Laravel Blade are kept in this folder, along with stylesheets and scripts that comprise the front-end.
    \item \textbf{storage} Laravel stores log files here, and generated PDF files for download are kept here. A cache for quick loading is also stored here.
    \item \textbf{tests} PHPUnit tests are kept here, and are covered in Chapter 6.
    \item \textbf{vendor} Similar to \textit{node\_modules}, this folder stores PHP dependencies used by Laravel, as well as additional third-party libraries.
\end{itemize} \cite{W3Schools1}

\section{Method of Action}
The Laravel developers acknowledge that having a basic, high-level understanding of how a framework works is important for not only having a basic grasp of how the application works, but also to make 'everything feel less magical'. \cite{Laravel6} This is important as frameworks are characterised by carrying out substantial amounts of work for you, in order to drastically reduce development time and to produce better quality applications, and are generally recommended by the greater web development community. \cite{Mozilla3}

\begin{figure}[!ht]
    \includegraphics[width=1.0\textwidth]{Figures/laravel-request}
    \caption{Diagram that shows how the Request Lifecycle for the Laravel framework operates.}
    \label{fig:laravel-requests} \cite{Mallow1}
\end{figure}

When a HTTP (Hypertext Transfer Protocol) request is received by the web server by navigating to the \textbf{index.php} file in the \textit{public} directory, the application is quickly bootstrapped, loading all necessary libraries and components by means of the PSR-4 autoload file, which is a widely accepted PHP coding standard and was generated by Composer, the PHP package manager when the application was first installed. \cite{PSR1} From here, the application can determine how to 'route' the request based on route definitions and the URL (Uniform Resource Locator) path, delegating actions to the appropriate controllers and their models defined in those definitions, before passing data to a view, and returning it to the user. \cite{Laravel6} According to Stauffer, Laravel's approach 'brings your ideas to reality with no wasted code' and 'modern programming standards.' \cite{LaravelUp1}

\section{HTTP Routes}

\begin{figure}[!ht]
    \includegraphics[width=1.0\textwidth]{Figures/routes}
    \caption{A print out of HTTP routes defined within the application, their corresponding URLs, associated controllers and methods, and HTTP actions.}
    \label{fig:methods}
\end{figure}

The controllers for each resource (i.e. users, operations) as well as individual webpages uses a RESTful (Representational State Transfer) architecture, and have methods that correspond to the CRUD verbs - create, read, update, and delete. There are also additional methods that help facilitate the CRUD operations, such as 'show' for viewing individual entries, and 'edit' to display a form in order to modify an existing record. Different actions may expect different HTTP requests, such as GET, POST, PATCH, and DELETE respectively. Each action, whether viewing one's own profile, editing a user's profile, registering for a shift, or deleting an operation, are all represented by their own route within the application, including custom defined routes that do not correspond to CRUD, such as those used for (de)registering to an operation. \cite{Laravel7} \cite{7539825}

\section{Models and Relationships}

\begin{figure}[!ht]
    \includegraphics[width=1.0\textwidth]{Figures/Models}
    \caption{UML diagram showing the relationships between database tables and their structure. The relationships are defined by their Eloquent relationships.}
    \label{fig:relationships}
\end{figure}

Database models define their column names and data types within migration files, alongside foreign keys, their references, and any constraints. As shown by Figure \ref{fig:relationships}, many of the tables belong to shifts, as each shift can have corresponding vehicles associated with it, a designated location, a required role and competency level, as well as the volunteer that is assigned to that volunteer, which is of course null when the shift is vacant.

\section{Views and Laravel Blade}

Controller methods, as part of their response to the user's request will return a view that can be populated with data processed or retrieved, such as returning the current resource object for display when viewing an individual item, like a role type. Laravel uses a language called Blade for its templating engine, which allows for reusable front-end code, and more legible syntax for inserting data into views or extending existing template files than using raw PHP alone, though vanilla PHP script is nevertheless supported and will be interpreted all the same. \cite{Laravel9} \cite{Underwood1}

An example of a data being passed to a view can be seen in the following code, that is taken from the controller for operations, where all operations retrieved from the database (by Eloquent) are injected into the view as an argument, to be parsed and displayed there:

\begin{lstlisting}[language=PHP, breaklines]
    public function index()
    {
        $operations = Operation::orderBy('date', 'desc')->paginate(3);
        return view('operation.index', compact('operations'));
    }
\end{lstlisting}

The name of the view to be rendered by Laravel is 'operation.index', which will now have access to the contents of \texttt{\$operations}. In the following snippet of Blade code, you can see the contents of this variable being iterated through and printed in tabular form, as well as the usage of vanilla PHP script where it has been deemed necessary:

\begin{lstlisting}[language=HTML, breaklines]
    <tbody>
    @foreach ($operations as $operation)
        @php
            $operationDate = \Carbon\Carbon::parse($operation->date);
        @endphp
        <tr>
        ...
        </tr>
        ...
    @endforeach
    </tbody>
\end{lstlisting}

\section{Users}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=1.0\textwidth]{Figures/screenshot-users}
    \caption{Screenshot of the Users interface within the application.}
    \label{fig:users}
\end{figure}

All volunteers are users within the application, with users that have access to administrative privileges being denoted by a boolean true value in \textbf{is\_admin}. Users can modify a subset of their own information, but are unable to assign themselves roles or privileges, or modify a date value indicating the last time they were inspected.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=1.0\textwidth]{Figures/screenshot-edit-user}
    \caption{Screenshot of the Edit User interface, as seen by an administrator.}
    \label{fig:users-edit}
\end{figure}

The following destroy CRUD method in the User controller, demonstrates how after checking the policies that the current user is authorised to delete a user (so is an administrator), it checks first whether they are attempting to delete themselves, which is understandably undesirable behaviour, and redirects back with an error message if this is the case. Otherwise, the \textbf{delete} Eloquent method is called on the user object, and it is deleted from the database; redirecting back with a success notification. The User object is resolved from the unique ID in the URL. \cite{Laravel7}

\begin{lstlisting}[language=PHP, breaklines]
    public function destroy(User $user)
    {
        $this->authorize('delete', $user);

        if ($user->id === Auth::id()) {
            flash()->error('You can\'t delete yourself!')->important();
            return redirect()->back();
        }

        $user->delete();
        flash()->success("{$user->name} has been deleted successfully!")->important();
        return redirect()->route('users.index');
    }
\end{lstlisting}

\subsection{Authentication}
Authentication functionality can be scaffolded seamlessly by Laravel by issuing the \texttt{php artisan make:auth} command at on the command line, and provides all the necessary registration, login, and password reset functionality - and automatically ties this into the User model.

By declaring routes within the authentication middleware group as the following code demonstrates, Laravel will ensure that a user is authenticated in order to access any of the routes contained therein, otherwise redirecting back to the login page. \cite{Laravel8}

\begin{lstlisting}[language=PHP, breaklines]
    Route::group(['middleware' => ['auth']], function() {
        Route::resource('users', 'UserController');
    }
\end{lstlisting}

\subsection{Authorisation and Policies}
Authorisation - determing who can and who cannot access resources or carry out certain actions is determined by classes known as policies within Laravel - where authorisation logic is stored. \cite{Larashout1} In this application, a policy is necessary wherever there are actions that users and administrators have different levels of access to, such as being able to create roles, operations, or modify user data.

A corresponding method is typically called in a controller's respective policy (i.e. UserController will have a matching policy called UserPolicy) and within the controller action itself, the appropriate method for that action is passed as an argument, alongside the currently authenticated user object, like thus:

\begin{lstlisting}[language=PHP, breaklines]
    $this->authorize('create', $user);
\end{lstlisting}

This calls the corresponding create method in its policy file, which will return either true for successful authorisation and allowing the remainder of the controller method to execute. Otherwise, the action is prevented. A call to this method absolutely must exist for any authorisation to occur, regardless of whether there is a corresponding policy class to the aforementioned controller and model. The corresponding 'create' policy method in the UserPolicy file is as follows:

\begin{lstlisting}[language=PHP, breaklines]
    public function create(User $user)
    {
        return $user->isAdmin();
    }
\end{lstlisting}

This simple but effective method calls a custom method on the model itself that returns whether or not the attribute \textbf{is\_admin} on the currently authenticated user is true or not. If the value isn't truthful, then execution halts as authorisation has subsequently failed.

\section{Role Types}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=1.0\textwidth]{Figures/screenshot-roletypes}
    \caption{Screenshot of the Role Types interface within the application.}
    \label{fig:users}
\end{figure}

In order to volunteer for a shift, a user must have the relevant role type that is also shared by the shift. For example, a shift might have a \textit{Blockman} vacancy available, but in order to volunteer for the role, they need to have that role themselves. Role types are treated as resources with CRUD routes, and can only be modified in any form by administrators.

Role types are not hardcoded into the system, and are their own database table, although a list of defaults is defined in the source code that can be used during initial setup, and consist of the following roles: 

\begin{itemize}
    \item Controller
    \item Guard
    \item Blockman
    \item Driver (Diesel/Electric)
    \item Driver (Steam)
    \item Museum Staff
\end{itemize}

Additional role types can be added to the system to accommodate any future needs of the railway, or existing ones may be modified or deleted as necessary.

\section{Role Competencies}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=1.0\textwidth]{Figures/screenshot-competency-create}
    \caption{Screenshot of an administrator adding a new competency level to the a driver role.}
    \label{fig:users}
\end{figure}

Each role can have multiple competency levels, each with their own tier between 1 and 10. Those with a competency in a specific role can volunteer for shifts equal or lesser to their numerical tier. 

For example, if there is a Blockman Shift requiring at least a Trainee, which have a numerical tier of 1, then those with Passed (2) or Examiner (3) can also sign up for the same work. If the shift required someone with Passed (2) level, then a Trainee (1) would not be able to register for it.

Each of the default role types have predefined default competencies also, but additional competencies can be added and those existing may also be modified. Furthermore, the numerical tiers are not unique, so multiple competencies for a role may share the same tier. Shifts can also not have tier requirements set, and can therefore be met by any level, including if a user does not have a competency level defined for whatever reason.

This algorithm that ensures that competency levels are met is explored in more detail in the Operations and Shift subsection.

\section{Roles}

\section{Locations and Locomotives}

\section{Operations and Shifts}

\section{Calendar View}

\section{PDF Export Functionality}

\section{Administration Panel}

\section{Additional Webpages}