\chapter{Critical Evaluation}

\section{Introduction}
The aims of this chapter are to provide a critical analysis and evaluation of various aspects of the development process, including providing insight into what could have been done better and the various shortcomings that could have been approached better throughout the lifecycle of the project. 

\section{Implementation of Requirements}

\subsection{Functional Requirements}
The requirements that were successfully implemented for this release of the project are as follows:

\begin{itemize}
    \item All users must be able to navigate the roster, and view current, upcoming, and/or historic shifts
    \item Users must be able to fill in and edit their personal information
    \item Users must be able to assign themselves to shifts of which they are able to do
    \item Users must \textbf{not} be able to assign themsleves to shifts that they are unable to do
    \item Users must be able to indicate periods of availability
    \item Users must be able to operate the web application easily from a mobile device such as a smartphone
    \item Administrators must be able to modify user information
    \item Administrators must be able to assign roles and privileges that reflect a volunteer's ability and status
    \item Administrators must be able to add, edit, and delete shifts
    \item Administrators must be able to mark a shift as closed
    \item Administrators must be able to define a shift's staffing requirements
    \item The application must run on a predetermined operating environment
\end{itemize}

The behaviours that were not successfully implemented are:

\begin{itemize}
    \item Users must \textbf{not} be able to assign themsleves to simultaneous roles on the same shifts
    \item Users must be able to indicate their willingness or desire to do an upcoming shift (i.e. an unspecified upcoming weekend)
    \item Administrators must be able to email users regarding upcoming shifts
\end{itemize}

The first of these two requirements was intentionally left out after a conversation with the client, where it was expressed that it was certainly possible for a particular volunteer to be carrying out more than one role, although unlikely, during an operation. This might be the case for example where an experienced member of staff is monitoring a trainee, whilst also carrying out some miscellaneous function. Nevertheless, should the customer change their mind on this and wish to have this requirement reinstated, it could be reverted in a straightforward manner.

The next point, being able to indicate willingness or desire to do an upcoming shift was actually overlooked and, due to human error, not implemented before development was frozen. While embarrassing, an important lesson can be learned from this experience on the importance on continuously ensuring and checking that requirements are being met at all stages of the project, and that any ongoing work should be directly attributable to a requirement, such as by using user stories. 

Lastly, the functionality to email users with upcoming shift information was simply not able to be implemented in time for the initial software release, purely a result of time constraints. This was communicated to the customer as a matter of urgency; reassuring them that it would be included in a future revision of software, and was met with approval.

Despite having missed three functional requirements within the first release, this success rate of 80\% is nevertheless a positive one, especially given that changes and feedback were continuously exchanged throughout the development process. This should be considered a successful delivery of functionality, which ultimately is the key indicator of progress and success in an agile software project. \cite{beck2001agile}

\subsection{Desirable Functionality}

Automated rostering was considered beyond the scope of this release due to it being a complicated computational problem, and following discussion with the customer, it was deemed not to be an issue, but perhaps functionality that could be considered in a distant future release as the number of railway volunteers increases. They also stressed that they did not want optional automated rostering from potentially complicating the UI of the application, which was what initially prompted its inception in the first place, as existing solution HOPS was considered too complex for the average user to navigate.

The ability to implement localisation into the program was researched and was considered for the first release. Ultimately however, time constraints made it necessary to triage this functionality for a future release. This was discussed with the customer, as due to the high number of Welsh speakers in Machynlleth \cite{Census1} this might be a greater priority than an initial analysis might reveal. The customer nevertheless provided reassurance that it was not necessary for a first release of the software, but would gladly welcome it in a future revision.

\section{Adherence to Agile Methodology}
Overall adherence to the hybrid FDD methodology was mostly successful, with the Build by Feature iteration taking up the vast majority of development time, and fitting comfortably within the predetermined timeframe. However, one of the major violations of this methodology that happened periodically was not producing unit or feature tests as components were developed, and simply moving onto the next feature or route - without a concrete indication of behaviour being done. In order to rectify this, substantial time had to be allocated to going back and ensuring adequate test coverage was in place to prevent any accidental regressions in behaviour.

Furthermore, it was difficult to remain within the confines of the timeframes used in place of Scrum sprints. With all the best planning and foresight in the world, certain real life events can occur that can be problematic obstacles for solo developers who do not have other software engineers whom they can delegate work to when problems arise. In spite of these difficulties, 80\% of planned required functionality has made it into the initial release, showing a great deal of adaptability and resourcefulness on the developer's behalf, which are crucial elements in agile software development in a world where, for better or for worse, programmers do not have psychic abilities.

\section{Difficulties Encountered with Domain Knowledge}
By far the greatest difficulty with this project was wrestling with an onslaught of specific domain knowledge and terminology unique to railways, steam railways, and the work carried out thereon. Whilst the customer made every effort possible to ensure a wealth of documentation and terminology guidelines were available, it remained nevertheless difficult to fully assimilate without slowing down development efforts. Some problems did arise from confusion regarding specific terminology at multiple points in development, but thankfully due to regular meetings with the client these problems were diagnosed early and could be quickly rectified with further clarification and insight from the customer. 

This truly demonstrates the importance of face-to-face meetings, or in this instance, oral conversation, where information can far more readily be transferred from customer to developer without the need of lengthy or confusing documentation. This theory is backed up by Chow et al who identified customer involvement as a strong indicator for success in agile projects. \cite{CHOW2008961}

In a nutshell, when faced with a project that requires a substantial deal of domain knowledge or expertise, it is best to communicate with those with that expertise, i.e. the customer, as much as possible so that any issues can be quickly rectified and that large portions of the codebase need not be re-engineered.

\section{Suitability of Development Choices}
The use of a framework like Laravel drastically reduced the amount of boilerplate code that would normally need to be written for an application. Not a single line of SQL (Structured Query Language) was even needed to be written for the program due to the amount of heavy lifting that the Eloqeunt ORM is capable of doing. For these reasons especially, the choice of Laravel for a development framework (and subsequently PHP as a language) was a fitting and appropriate choice. After speaking informally with a colleague who was embarking on a similar but unrelated endeavour using vanilla PHP, it became apparent just how much database code that they had to write, which could be replicated with a simple Eloquent method under Laravel.

It is believed however that the use of Python and Django together would have been equally as sufficient as the offerings of said framework are similar, but this would have involved significantly more learning, and with some of the real life obstacles that slowed down development, this could have caused further unnecessary delays. It can be concluded that choosing a fully featured framework was the correct choice, instead of potentially needing to 'reinvent the wheel' by either using a more cut down framework like Express, or using no framework at all. This is really evident when one evaluates how much code and checks must be put into place for a comprehensive and secure authentication and authorisation system to work, but with Laravel, one only needs to put into place policies and call the appropriate method. \cite{Laravel8}

\section{Improvements to Testing Methodology}
Whilst the automated and manual test coverage is great and covers almost all Railrota functionality, one crucially missing element from the testing is ensuring that the application is easy to use for the customer - as the customer, or any other prospective volunteer, has not had the opportunity to testrun the software, besides being shown video demos during meetings.

A major improvement to the testing methodology that should be rectified in the future, would be to host regular meetings with the customer, and preferably prosepctive users, and allow them to operate the software freely and without prompt - recording their behaviour and feedback to make improvements to the user experience. (UX)

\section{Shortcomings and Recommendations for Further Releases}
Whilst the software is generally good quality expected of a Master's level software engineer, it is not without flaws indicative of someone learning a web framework for the first time.

One of the most glaring code smells that would be come immediately obvious to any experienced developer is the reusage of code, both within controllers and within Laravel Blade templates. Although effort has been undertaken to ensure that code is compartmentalised as much as possible so that it is not reused, particularly in controllers, there is a lot of code that simply gets repeated. Moving some of this shared code into shared methods, or simply redesigning the algorithms into more concise functions would help clean up a lot of this underlying programming.

Furthermore, while much of the web interface has been abstracted into partial templates for reusage, there are large portions of Blade logic that are repeated, and more effort could be made to reduce their reoccurance so that if something needs to be changed, it can be changed once, rather than in multiple positions. Due to time constraints during development, the decision of 'function over form' had to be undertaken, which is reportedly common in many agile projects. However, for future revisions, developers should look to undo these code smells and make the code more maintainable for future work.